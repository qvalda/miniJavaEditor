package tokenizer

object Tokens {
    val brackets = mapOf(
        '(' to TokenType.BracketRoundOpen,
        ')' to TokenType.BracketRoundClose,
        '[' to TokenType.BracketSquareOpen,
        ']' to TokenType.BracketSquareClose,
        '{' to TokenType.BracketCurlyOpen,
        '}' to TokenType.BracketCurlyClose,
    )

    val symbols = mapOf(
        '.' to TokenType.SymbolDot,
        ',' to TokenType.SymbolComma,
        ';' to TokenType.SymbolSemicolon,
        ':' to TokenType.SymbolColon,
    )

    val booleans = mapOf(
        "true" to TokenType.LiteralTrue,
        "false" to TokenType.LiteralFalse,
        "null" to TokenType.LiteralNull,
    )

    val operators = mapOf(
        "==" to TokenType.OperatorEquals,
        "!=" to TokenType.OperatorNotEquals,
        "<=" to TokenType.OperatorLessOrEqual,
        ">=" to TokenType.OperatorMoreOrEqual,
        "--" to TokenType.OperatorDecrement,
        "++" to TokenType.OperatorIncrement,
        "-=" to TokenType.OperatorMinusAssign,
        "+=" to TokenType.OperatorPlusAssign,
        "*=" to TokenType.OperatorMultAssign,
        "/=" to TokenType.OperatorDivAssign,
        "&&" to TokenType.OperatorAnd,
        "||" to TokenType.OperatorOr,
        "!" to TokenType.OperatorNot,
        "=" to TokenType.OperatorAssign,
        "<" to TokenType.OperatorLess,
        ">" to TokenType.OperatorMore,
        "+" to TokenType.OperatorPlus,
        "-" to TokenType.OperatorMinus,
        "/" to TokenType.OperatorDiv,
        "*" to TokenType.OperatorMult,
    )

    val keyWords = mapOf(
        "abstract" to TokenType.KeyWordAbstract,
        "continue" to TokenType.KeyWordContinue,
        "for" to TokenType.KeyWordFor,
        "new" to TokenType.KeyWordNew,
        "switch" to TokenType.KeyWordSwitch,
        "assert" to TokenType.KeyWordAssert,
        "default" to TokenType.KeyWordDefault,
        "goto" to TokenType.KeyWordGoto,
        "package" to TokenType.KeyWordPackage,
        "synchronized" to TokenType.KeyWordSynchronized,
        "boolean" to TokenType.KeyWordBoolean,
        "do" to TokenType.KeyWordDo,
        "if" to TokenType.KeyWordIf,
        "private" to TokenType.KeyWordPrivate,
        "this" to TokenType.KeyWordThis,
        "break" to TokenType.KeyWordBreak,
        "double" to TokenType.KeyWordDouble,
        "implements" to TokenType.KeyWordImplements,
        "protected" to TokenType.KeyWordProtected,
        "throw" to TokenType.KeyWordThrow,
        "byte" to TokenType.KeyWordByte,
        "else" to TokenType.KeyWordElse,
        "import" to TokenType.KeyWordImport,
        "public" to TokenType.KeyWordPublic,
        "throws" to TokenType.KeyWordThrows,
        "case" to TokenType.KeyWordCase,
        "enum" to TokenType.KeyWordEnum,
        "instanceof" to TokenType.KeyWordInstanceof,
        "return" to TokenType.KeyWordReturn,
        "transient" to TokenType.KeyWordTransient,
        "catch" to TokenType.KeyWordCatch,
        "extends" to TokenType.KeyWordExtends,
        "int" to TokenType.KeyWordInt,
        "short" to TokenType.KeyWordShort,
        "try" to TokenType.KeyWordTry,
        "char" to TokenType.KeyWordChar,
        "final" to TokenType.KeyWordFinal,
        "interface" to TokenType.KeyWordInterface,
        "static" to TokenType.KeyWordStatic,
        "void" to TokenType.KeyWordVoid,
        "class" to TokenType.KeyWordClass,
        "finally" to TokenType.KeyWordFinally,
        "long" to TokenType.KeyWordLong,
        "strictfp" to TokenType.KeyWordStrictfp,
        "volatile" to TokenType.KeyWordVolatile,
        "const" to TokenType.KeyWordConst,
        "float" to TokenType.KeyWordFloat,
        "native" to TokenType.KeyWordNative,
        "super" to TokenType.KeyWordSuper,
        "while" to TokenType.KeyWordWhile,
        "String" to TokenType.KeyWordString,
    )
}