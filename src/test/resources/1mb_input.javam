class BinaryTree{
	public static void main(String[] a){
		System.out.println(new BT().Start());
	}
}


// This class invokes the methods to create a tree,
// insert, delete and serach for  elements on it
class BT {

	public int Start(){
		Tree root ;
		boolean ntb ;
		int nti ;

		root = new Tree();
		ntb = root.Init(16);
		ntb = root.Print();
		System.out.println(100000000);
		ntb = root.Insert(8) ;
		ntb = root.Print();
		ntb = root.Insert(24) ;
		ntb = root.Insert(4) ;
		ntb = root.Insert(12) ;
		ntb = root.Insert(20) ;
		ntb = root.Insert(28) ;
		ntb = root.Insert(14) ;
		ntb = root.Print();
		System.out.println(root.Search(24));
		System.out.println(root.Search(12));
		System.out.println(root.Search(16));
		System.out.println(root.Search(50));
		System.out.println(root.Search(12));
		ntb = root.Delete(12);
		ntb = root.Print();
		System.out.println(root.Search(12));

		return 0 ;
	}

}

class Tree1{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree2{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree3{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree4{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree5{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree6{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree7{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree8{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree9{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree10{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree11{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree12{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree13{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree14{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree15{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree16{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree17{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree18{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree19{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree20{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree21{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree22{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree23{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree24{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree25{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree26{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree27{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree28{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree29{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree30{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree31{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree32{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree33{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree34{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree35{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree36{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree37{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree38{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree39{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree40{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree41{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree42{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree43{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree44{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree45{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree46{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree47{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree48{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree49{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree50{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree51{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree52{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree53{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree54{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree55{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree56{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree57{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree58{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree59{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree60{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree61{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree62{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree63{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree64{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree65{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree66{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree67{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree68{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree69{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree70{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree71{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree72{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree73{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree74{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree75{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree76{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree77{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree78{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree79{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree80{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree81{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree82{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree83{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree84{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree85{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree86{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree87{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree88{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree89{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree90{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree91{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree92{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree93{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree94{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree95{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree96{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree97{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree98{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree99{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree100{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree101{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree102{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree103{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree104{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree105{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree106{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree107{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree108{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree109{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree110{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree111{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree112{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree113{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree114{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree115{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree116{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree117{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree118{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree119{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree120{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree121{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree122{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree123{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree124{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree125{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree126{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree127{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree128{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree129{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree130{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree131{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree132{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree133{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree134{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree135{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree136{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree137{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree138{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree139{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree140{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree141{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree142{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree143{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree144{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree145{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree146{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree147{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree148{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree149{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree150{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree151{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree152{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree153{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree154{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree155{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree156{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree157{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree158{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree159{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
class Tree160{
	Tree left ;
	Tree right;
	int key ;
	boolean has_left ;
	boolean has_right ;
	Tree my_null ;

	// Initialize a node with a key value and no children
	public boolean Init(int v_key){
		key = v_key ;
		has_left = false ;
		has_right = false ;
		return true ;
	}

	// Update the right child with rn
	public boolean SetRight(Tree rn){
		right = rn ;
		return true ;
	}

	// Update the left child with ln
	public boolean SetLeft(Tree ln){
		left = ln ;
		return true ;
	}

	public Tree GetRight(){
		return right ;
	}

	public Tree GetLeft(){
		return left;
	}

	public int GetKey(){
		return key ;
	}

	public boolean SetKey(int v_key){
		key = v_key ;
		return true ;
	}

	public boolean GetHas_Right(){
		return has_right ;
	}

	public boolean GetHas_Left(){
		return has_left ;
	}

	public boolean SetHas_Left(boolean val){
		has_left = val ;
		return true ;
	}

	public boolean SetHas_Right(boolean val){
		has_right = val ;
		return true ;
	}

	// This method compares two integers and
	// returns true if they are equal and false
	// otherwise
	public boolean Compare(int num1 , int num2){
		boolean ntb ;
		int nti ;

		ntb = false ;
		nti = num2 + 1 ;
		if (num1 < num2) ntb = false ;
		else if (!(num1 < nti)) ntb = false ;
		else ntb = true ;
		return ntb ;
	}


	// Insert a new element in the tree
	public boolean Insert(int v_key){
		Tree new_node ;
		boolean ntb ;
		boolean cont ;
		int key_aux ;
		Tree current_node ;

		new_node = new Tree();
		ntb = new_node.Init(v_key) ;
		current_node = this ;
		cont = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux){
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Left(true);
					ntb = current_node.SetLeft(new_node);
				}
			}
			else{
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else {
					cont = false ;
					ntb = current_node.SetHas_Right(true);
					ntb = current_node.SetRight(new_node);
				}
			}
		}
		return true ;
	}


	// Delete an element from the tree
	public boolean Delete(int v_key){
		Tree current_node ;
		Tree parent_node ;
		boolean cont ;
		boolean found ;
		boolean is_root ;
		int key_aux ;
		boolean ntb ;

		current_node = this ;
		parent_node = this ;
		cont = true ;
		found = false ;
		is_root = true ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left()){
					parent_node = current_node ;
					current_node = current_node.GetLeft() ;
				}
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right()){
					parent_node = current_node ;
					current_node = current_node.GetRight() ;
				}
				else cont = false ;
			else {
				if (is_root)
					if ((!current_node.GetHas_Right()) &&
							(!current_node.GetHas_Left()) )
						ntb = true ;
					else
						ntb = this.Remove(parent_node,current_node);
				else ntb = this.Remove(parent_node,current_node);
				found = true ;
				cont = false ;
			}
			is_root = false ;
		}
		return found ;
	}


	// Check if the element to be removed will use the
	// righ or left subtree if one exists
	public boolean Remove(Tree p_node, Tree c_node){
		boolean ntb ;
		int auxkey1 ;
		int auxkey2 ;

		if (c_node.GetHas_Left())
			ntb = this.RemoveLeft(p_node,c_node) ;
		else
		if (c_node.GetHas_Right())
			ntb = this.RemoveRight(p_node,c_node) ;
		else {
			auxkey1 = c_node.GetKey();
			//auxtree01 = p_node.GetLeft() ;
			//auxkey2 = auxtree01.GetKey() ;
			auxkey2 = (p_node.GetLeft()).GetKey() ;
			if (this.Compare(auxkey1,auxkey2)) {
				ntb = p_node.SetLeft(my_null);
				ntb = p_node.SetHas_Left(false);
			}
			else {
				ntb = p_node.SetRight(my_null);
				ntb = p_node.SetHas_Right(false);
			}
		}
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// right subtree
	public boolean RemoveRight(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Right()){
			//auxtree01 = c_node.GetRight() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetRight()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetRight() ;
		}
		ntb = p_node.SetRight(my_null);
		ntb = p_node.SetHas_Right(false);
		return true ;
	}


	// Copy the child key to the parent until a leaf is
	// found and remove the leaf. This is done with the
	// left subtree
	public boolean RemoveLeft(Tree p_node, Tree c_node){
		boolean ntb ;

		while (c_node.GetHas_Left()){
			//auxtree01 = c_node.GetLeft() ;
			//auxint02 = auxtree01.GetKey();
			//ntb = c_node.SetKey(auxint02);
			ntb = c_node.SetKey((c_node.GetLeft()).GetKey());
			p_node = c_node ;
			c_node = c_node.GetLeft() ;
		}
		ntb = p_node.SetLeft(my_null);
		ntb = p_node.SetHas_Left(false);
		return true ;
	}

	// Search for an elemnt in the tree
	public int Search(int v_key){
		boolean cont ;
		int ifound ;
		Tree current_node;
		int key_aux ;

		current_node = this ;
		cont = true ;
		ifound = 0 ;
		while (cont){
			key_aux = current_node.GetKey();
			if (v_key < key_aux)
				if (current_node.GetHas_Left())
					current_node = current_node.GetLeft() ;
				else cont = false ;
			else
			if (key_aux < v_key)
				if (current_node.GetHas_Right())
					current_node = current_node.GetRight() ;
				else cont = false ;
			else {
				ifound = 1 ;
				cont = false ;
			}
		}
		return ifound ;
	}

	// Invoke the method to really print the tree elements
	public boolean Print(){
		Tree current_node;
		boolean ntb ;

		current_node = this ;
		ntb = this.RecPrint(current_node);
		return true ;
	}

	// Print the elements of the tree
	public boolean RecPrint(Tree node){
		boolean ntb ;

		if (node.GetHas_Left()){
			//auxtree01 = node.GetLeft() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetLeft());
		} else ntb = true ;
		System.out.println(node.GetKey());
		if (node.GetHas_Right()){
			//auxtree01 = node.GetRight() ;
			//ntb = this.RecPrint(auxtree01);
			ntb = this.RecPrint(node.GetRight());
		} else ntb = true ;
		return true ;
	}

}
